 <iostream>
#include "src/system/Auth.h"
#include <experimental/coroutine>
using namespace std;

template <class T>
using coroutine_handle = experimental::coroutine_handle<T>;

// promise.get_return_object()
// promise.initial_suspend() first co_await generated by the compiler
// promise.unhandled_exception() for handling exceptions from coroutines
// promise.final_suspend() logic for co_return
// promise.yield_value() for co_yield
// promise.return_void() for co_return (co_await promise.return_void())
// promise.return_object() for co_return <expr>

// co_await <expr> where is expression is for controlling suspencion of that function
// co_await std::suspend_always(); <- just suspend



class resumable;

class resumable_iterator {
public:
  resumable_iterator(resumable& resumable): handle_(resumable) {}
  void operator++();
  int operator*();
  bool operator!=(const resumable_iterator&);
private:
  resumable& handle_;
};

struct resumable {

  struct promise {
    using co_handle = coroutine_handle<promise>;

    struct awaiter {
      bool await_ready() { return false; }
      void await_suspend(co_handle handle) {}
      void await_resume() {}
    };

    // magic
    resumable get_return_object() { return co_handle::from_promise(*this); }

    auto initial_suspend() {
      return awaiter{};
    }

    auto final_suspend() noexcept { return experimental::suspend_always(); }

    auto yield_value(int a) {
      value = a;
      return awaiter{};
    }

    void return_void() {}

    void unhandled_exception() { terminate(); }

    int value = 0;
  };

  using promise_type = promise;
  using co_handle = experimental::coroutine_handle<promise>;


  resumable(co_handle handle): handle_(handle) {}

  resumable(resumable& other) =delete;

  resumable(resumable&& other) {
    handle_ = other.handle_;
    other.handle_ = nullptr;
  }

  resumable_iterator begin() {
    handle_.resume();
    return *this;
  }

  resumable_iterator end() {
    return *this;
  }

  bool done() {
    return handle_.done();
  }

  bool resume() {
    if (!handle_.done()) { handle_.resume(); }
    return !handle_.done();
  }

  int current_value() {
    return handle_.promise().value;
  }

  ~resumable() {
    handle_.destroy();
  }

private:
  co_handle handle_;
};


void resumable_iterator::operator++() {
  handle_.resume();
}

int resumable_iterator::operator*() {
  return handle_.current_value();
}

bool resumable_iterator::operator!=(const resumable_iterator& other) {
  return !handle_.done();
}

resumable cor() {
  int start = 0;
  for (int i = 0; i < 10; i++) {
    co_yield start;
    start++;
  }
}

int a = 5;
int main() {
  int b = 4;
  static int c = 3;
  auto f = [=](){
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;
  };
  f();
  cout << endl;

  a = 1;
  b = 1;
  c = 1;
  f();

  return 0;
}