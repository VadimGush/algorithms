
# C++ coroutines

Layout:
 * Promise object (user defined) - tells what to do on initial suspend, final suspend and in case of exceptions.
     Promise object also has "value" inside which represents value that should be returned by the coroutine.
 * Coroutine state - generated by the compiler object. Contains promise object inside.
 * Return object (user defined) - contains coroutine handle (pointer to the coroutine state) in order to control it.
 * Awaiter (user defined) - tells what to do in case of `co_await` call.

Creation of coroutine:
 1. Creates `coroutine state` object with operator `new()`
 2. Creates `promise` object inside that coroutine state by calling promise constructor
 3. Constructs `return object` with `promise::get_return_object()`
 4. Calls `promise::initial_suspend()`

```
   (user)       (compiler)          (user)
  promise -> coroutine_handle -> return_object
```

## How to define a coroutine

 1. Define Promise
    * what to do on first suspend
    * what to do on last suspend
    * what to do on any suspend or return
 2. Compiler will create coroutine state with coroutine_handle
 3. Define return_object
    * What to do with that coroutine using the created coroutine_handle

When defining promise you should provide those methods:

### promise lifetime

 * `promise.get_return_object()` - constructing of return_object for coroutine handle
 * `promise.initial_suspend()` - logic for first co_await generated by the compiler
 * `promise.final_suspend()` - logic after co_return;
 * `promise.unhandled_exception()` - for handling exceptions from coroutines
 * `(optional) promise.await_transform(awaiter)` - to transform awaiter from co_await

### co_return / co_yield support

 * `promise.yield_value()` - for co_yield (co_await promise.yield_value(expr))
 * `promise.return_void()` - for co_return (co_await promise.return_void())
 * `promise.return_value()` - for co_return <expr> (co_await promise.return_value(expr))

## Awaiter

When `co_await <awaiter>` is called it runs code that looks like this:
```c++
auto awaiter = /*...*/; // awaiter in co_await awaiter

if (!awaiter.await_ready()) {
  // 1. await_suspend returns void
  awaiter.await_suspend(handle);
  suspend_and_exit();
  
  // 2. await_suspend returns bool
  bool suspend = awaiter.await_suspend(handle);
  if (suspend) suspend_and_exit();
  else resume();
  
  // 3. await_suspend returns coroutine_handle (handle to another coroutine)
  auto another_handle = awaiter.await_suspend(handle);
  suspend();
  another_handle.resume();
}

// result is the result of "co_await awaiter" call
// auto result = co_await awaiter;
auto result = awaiter.await_resume();

```

"co_await awaiter" and what it is. Awaiter is basically something like this:

```
 struct awaiter {
   bool await_ready(); <- are we able to make progress further?

   void await_suspend(coroutine_handle); <- what to do if we're not ready and there is suspend
   (optional) bool await_suspend(coroutine_handle); <- do we want to suspend or not?
   (optional) coroutine_handle await_suspend(coroutine_handle); <- suspend this coroutine and resume other (from return object)

   void await_resume(); <- what to do if we're ready and progress is resumed
   (optional) T await_resume(); <- for T something = co_await awaiter;
 }
```