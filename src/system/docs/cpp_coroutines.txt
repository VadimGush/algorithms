
Creation of coroutine:

  (user)     (user)       (compiler)          (user)
 awaiter | promise -> coroutine_handle -> return_object

 1. Define Promise
    * what to do on first suspend
    * what to do on last suspend
    * what to do on any suspend or return
 2. C++ will create coroutine_handle from that promise
    * coroutine handle allows controlling of the coroutine
 3. Define return_object
    * What to do with that coroutine using the created coroutine_handle

When defining promise you should provide those methods:

 promise lifetime
 * promise.get_return_object() <- constructing of return_object for coroutine handle
 * promise.initial_suspend() <- logic for first co_await generated by the compiler
 * promise.final_suspend() <- logic after co_return;
 * promise.unhandled_exception() <- for handling exceptions from coroutines
 * (optional) promise.await_transform(awaiter) <- to transform awaiter from co_await

 co_return / co_yield support
 * promise.yield_value() <- for co_yield (co_await promise.yield_value(expr))
 * promise.return_void() <- for co_return (co_await promise.return_void())
 * promise.return_value() <- for co_return <expr> (co_await promise.return_value(expr))

"co_await awaiter" and what it is. Awaiter is basically something like this:

 struct awaiter {
   bool await_ready(); <- are we able to make progress further?

   void await_suspend(coroutine_handle); <- what to do if we're not ready and there is suspend
   (optional) bool await_suspend(coroutine_handle); <- do we want to suspend or not?
   (optional) coroutine_handle await_suspend(coroutine_handle); <- suspend this coroutine and resume other (from return object)

   void await_resume(); <- what to do if we're ready and progress is resumed
   (optional) T await_resume(); <- for T something = co_await awaiter;
 }