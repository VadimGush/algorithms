
Note: you can't overload from std namespace, but you can specialize

Templates for structures
  template <class T, class P = <default type>> struct A {}
  template <class T, int A> struct A {} // integral, floating-point, enum types also work

Specialization for structures
  template <> struct A<int> {} // specialization for only "int" type
  template <class T> struct A<vector<T>> {} // specialization for everything that looks like "vector<T>"

Partial specialization (doesn't work for functions)
  template <class T> struct A <T*> {} // specialization for all pointer types

Templates for functions
  template <class T> void fn(T p);

Specialization for functions
  template <> void fn<int>(int p);
  or
  template <> void function(int p); // let compiler guess the type

Restrict certain types through specialization
  template <> void function<int>() = delete; // delete function for type int

TRICK SITUATIONS

  (two-phase name resolution)
  template <class T> void foo(T) { cout << "T"; }
  struct S;
  template <class T> void foo_bar(T t, S s) {
    foo(s); // resolved on declaration (it doesn't depend on any template param) [first phase]
    foo(t); // resolved on instantiation (it depends on yet unknown T) [second phase]
  }
  foo(S) { cout << "S"; }
  int bar(S x) {
    foo_bar(x, x); // result: TS
  }

  (two-phase name resolution)
  template <class T> class Base { void exit() {}; }
  template <class T> class Child : Base<T> {
    void foo() {
      exit(); // ERROR! we can't resolve that name on the first phase (it doesn't depend on anything)
      // FIX
      this->exit();
      Base::exit();
    }
  }

  (ambiguous names)
  struct S { struct subtype {} }
  template <class T> int foo {
    S::subtype* a; // ERROR! for compiler looks like multiplication (S::member * a);
    // FIX
    typename S::subtype* a; // hey, compiler! look, it's a fucking type, not a member of a struct
  }

  template <class T> struct S {
     template <class U> foo() {} }
  S<T> s;
  s.foo<T>(); // ERROR! s.foo looks like member of type S (dammit!)
  // FIX
  s.template foo<T>();

  // What if we want to define a method which is inside two templates?
  template <class T> struct S {
    template <class U> U foo();
  }
  // yep, you need to write template<T> two times
  template <class T>
  template <class U>
  U foo() {}


